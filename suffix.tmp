<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spam Invaders</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#f1f4ff; --ink:#1f2a44; --accent:#5a65d8; --danger:#d94f6a; --gold:#ffc857;
  }
  *{box-sizing:border-box}
  html,body{height:100%; overflow:hidden;}
  body{
    margin:0; display:grid; place-items:center; background:var(--bg);
    color:var(--ink); font-family:'Tahoma', 'Verdana', sans-serif; letter-spacing:.3px;
  }
  .frame{
    position:relative; width:388px; height:576px; max-width:96vw; background:#ffffff;
    border:2px solid rgba(118,130,182,.45); box-shadow:0 8px 32px rgba(31,42,68,.18), inset 0 0 0 1px rgba(255,255,255,.65);
    overflow:hidden; border-radius:9px;
  }
  .frame::after{content:none;}
  header,footer{position:absolute;left:0;right:0;z-index:3;display:flex;align-items:center;padding:9px 14px}
  header{
    top:0; bottom:auto; justify-content:center;
    background:#e9ecff; gap:12px;
    border-bottom:1px solid rgba(123,136,194,.35);
    box-shadow:0 2px 8px rgba(42,52,94,.18);
    color:var(--ink);
  }
  footer{
    bottom:0; top:auto; justify-content:center; font-size:8px; text-transform:uppercase;
    background:#eef1ff;
    border-top:1px solid rgba(133,146,209,.28);
    box-shadow:0 -2px 8px rgba(42,52,94,.18);
  }
  .hudBlock{
    display:flex; flex-direction:column; gap:2px; min-width:88px;
  }
  .hudLabel{
    font-size:10px; text-transform:uppercase; color:rgba(70,86,146,.75); letter-spacing:.5px;
  }
  .hudValue{
    font-size:14px; color:#24335c; font-variant-numeric:tabular-nums; display:inline-block; min-width:72px;
  }
  .hudTight{min-width:auto; flex:0 0 auto;}
  .gauge{
    position:relative; width:115px; height:9px; border:1px solid rgba(112,142,204,.45); background:rgba(142,158,214,.12);
  }
  .gauge i{
    position:absolute; inset:1px; background:linear-gradient(90deg,var(--accent),#8aa4ff); transform-origin:left center;
  }
  .footerBar{
    width:100%; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
  }
  .statusGroup{
    display:flex; align-items:center; gap:14px;
  }
  .lives{
    display:flex; gap:5px;
  }
  .life{
    width:12px; height:9px; background:var(--accent); box-shadow:0 0 4px rgba(90,101,216,.35);
  }
  .ghost{opacity:.2}
  canvas{
    position:absolute; top:96px; left:16px; width:357px; height:441px; background:#ffffff; z-index:1;
    image-rendering:pixelated;
    border:1px solid rgba(187,195,230,.45);
  }
  footer .tickerLabel{
    margin-right:12px; color:#253377;
  }
  footer .tickerText{
    animation:tickerBlink 1.4s steps(2,end) infinite; color:#42508b;
  }
  @keyframes tickerBlink{0%,49%{opacity:.18}50%,100%{opacity:1}}
  @keyframes alertFlash{0%,45%{opacity:1}55%,100%{opacity:.2}}
  .overlay{
    position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
    background:rgba(0,0,0,.9); z-index:5; text-align:center; padding:20px; text-transform:uppercase; gap:12px;
  }
  .overlay h1{color:var(--accent);margin:0;font-size:14px;}
  .overlay p{max-width:360px;color:#bce2c6;margin:0;font-size:8px;line-height:1.6;}
  .overlay-boss h1{color:var(--danger);font-size:16px;animation:alertFlash .6s steps(2,end) infinite;}
  .overlay-boss p{font-size:10px;color:var(--accent);letter-spacing:1px;}
  .btn{
    display:inline-block; padding:9px 14px; background:transparent; color:var(--accent); border:2px solid var(--accent);
    border-radius:0; font-size:9px; cursor:pointer; box-shadow:0 0 9px rgba(109,255,151,.4); text-transform:uppercase; letter-spacing:1.4px;
  }
  .btn:hover{background:rgba(109,255,151,.25); color:#041b0b;}
  .bossbar{
    position:absolute; left:14px; right:14px; top:54px; height:9px; z-index:4;
    border:1px solid rgba(255,223,75,.45); border-radius:6px; overflow:hidden; background:rgba(255,223,75,.08); display:none;
  }
  .bossbar i{
    display:block; height:100%; background:linear-gradient(90deg,var(--gold),#ffeaa0); transform-origin:left center;
  }
  .bosslabel{
    position:absolute; top:42px; left:14px; z-index:4; font-size:7px; color:#ffe07e; text-shadow:0 0 5px rgba(255,223,75,.35); display:none;
  }
</style>
</head>
<body>
  <div class="frame">
    <header class="hud">
      <div class="headerStats">
        <div class="hudBlock">
          <span class="hudLabel">Score</span>
          <span class="hudValue" id="hudScore">00000</span>
        </div>
        <div class="hudBlock">
          <span class="hudLabel">Hi-Score</span>
          <span class="hudValue" id="hudHigh">00000</span>
        </div>
        <div class="hudBlock hudTight">
          <span class="hudLabel">Folder</span>
          <span class="hudValue" id="hudLevel">LEVEL 01</span>
        </div>
      </div>
    </header>

    <div class="bosslabel" id="bossLabel">BOSS INCOMING</div>
    <div class="bossbar" id="bossBar"><i id="bossFill" style="transform:scaleX(1)"></i></div>

    <canvas id="game" width="357" height="441"></canvas>

    <footer>
      <div class="footerBar">
        <div class="statusGroup">
          <div class="hudBlock hudTight">
            <span class="hudLabel">Shield</span>
            <div class="gauge"><i id="capacityFill" style="transform:scaleX(1)"></i></div>
          </div>
          <div class="hudBlock hudTight">
            <span class="hudLabel">Lives</span>
            <div class="lives" id="hearts"></div>
          </div>
        </div>
        <div class="ticker">
          <span class="tickerLabel">Command</span>
          <span class="tickerText">LEFT/RIGHT MOVE  -  SPACE FIRE  -  PRESS START</span>
        </div>
      </div>
    </footer>

    <!-- Start -->
    <div class="overlay" id="start">
      <h1>[ INSERT COIN ]</h1>
      <p>Sector mailbox under attack.<br>Deploy spam filters and defend the archive.</p>
      <button class="btn" id="btnStart">START</button>
    </div>

    <!-- Level Cleared -->
    <div class="overlay" id="cleared" style="display:none">
      <h1>[ INBOX SECURED ]</h1>
      <p>The Prince has been unsubscribed. System rebooting..</p>
      <button class="btn" id="btnNext">NEXT STAGE</button>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="gameover" style="display:none">
      <h1>[ MAILBOX BREACHED ]</h1>
      <p>Spam levels critical. Inbox overload. Systems throttled.</p>
      <button class="btn" id="btnAgain">TRY AGAIN</button>
    </div>

    <!-- Boss Intro -->
    <div class="overlay overlay-boss" id="bossIntro" style="display:none">
      <h1 id="bossIntroTitle">[ INCOMING THREAT ]</h1>
      <p id="bossIntroName">BOSS INCOMING</p>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const hudLevel = document.getElementById('hudLevel');
  const capacityFill = document.getElementById('capacityFill');
  const bossBar = document.getElementById('bossBar');
  const bossFill = document.getElementById('bossFill');
  const bossLabel = document.getElementById('bossLabel');
  const hudScore = document.getElementById('hudScore');
  const hudHigh = document.getElementById('hudHigh');
  const heartsEl = document.getElementById('hearts');
  const tickerText = document.querySelector('.tickerText');

  const elStart = document.getElementById('start');
  const elCleared = document.getElementById('cleared');
  const elGameOver = document.getElementById('gameover');
  const elBossIntro = document.getElementById('bossIntro');
  const bossIntroTitle = document.getElementById('bossIntroTitle');
  const bossIntroName = document.getElementById('bossIntroName');

  document.getElementById('btnStart').onclick = () => startNewRun();
  document.getElementById('btnNext').onclick  = () => nextLevel();
  document.getElementById('btnAgain').onclick = () => startNewRun();

  let keys = {};
  let state = 'menu';
  const playerBase = { w:40, h:12, speed:5, maxHP:3 };
  let player, bullets, enemyBullets, boss, score, level, inbox;
  let swarm;
  let lastTime = 0;
  let highScore = 0;
  let princeFX = null;
  let pendingBossSpec = null;
  let bossIntroTimeout = null;
  let currentEntry = null;
  let currentEntryId = null;
  let currentBossDef = null;
  let currentSubject = '';
  let subjectCycle = 0;
  let powerUps = [];

  const CAMPAIGN = [
    {
      id: 1,
      title: "Clickbait Cloud",
      tone: "funny / tutorial",
      palette: ["#aefaff","#b8ffd8"],
      subjects: [
        "Singles In Your Area.exe",
        "Guaranteed Weight Loss (No Effort Required)",
        "5% Off Something Stupid"
      ],
      boss: "influencer"
    },
    {
      id: 2,
      title: "Phishing Swarm",
      tone: "office anxiety",
      palette: ["#ffc14a","#ff5a2b"],
      subjects: [
        "Urgent Invoice Attached!",
        "Re: Re: Re: Final Notice",
        "Free Vacation Voucher (Limited Time!)"
      ],
      boss: "phishmaster"
    },
    {
      id: 3,
      title: "Crypto Carnage",
      tone: "neon greed",
      palette: ["#00ff99","#ff00aa"],
      subjects: [
        "Crypto Goes 1000x Tonight!!!",
        "Exclusive NFT Opportunity"
      ],
      boss: "coinlord"
    },
    {
      id: 4,
      title: "Royal Scam",
      tone: "theatrical corruption",
      palette: ["#ffd24a","#b21b1b"],
      subjects: [
        "Prince Requests Your Aid (Re: Inheritance Transfer)"
      ],
      boss: "prince"
    }
  ];

  const BOSSES = {
    influencer: {
      id: 'influencer',
      displayName: 'INFLUENCER.EXE',
      tagline: 'Smash that subscribe button or perish.',
      attack: 'heartFan',
      color: '#ff6ad5',
      accent: '#ffffff',
      size: { w: 120, h: 80 },
      speed: 1.5
    },
    phishmaster: {
      id: 'phishmaster',
      displayName: 'PHISHMASTER 3000',
      tagline: 'Your credentials are my currency.',
      attack: 'aimedShot',
      color: '#ff8a33',
      accent: '#ffe7c2',
      size: { w: 140, h: 90 },
      speed: 1.6
    },
    coinlord: {
      id: 'coinlord',
      displayName: 'COINLORD.v3',
      tagline: 'In volatility we trust.',
      attack: 'coinRain',
      color: '#00ff99',
      accent: '#ff00aa',
      size: { w: 170, h: 90 },
      speed: 1.8
    },
    prince: {
      id: 'prince',
      displayName: 'NIGERIAN PRINCE AI v7.3',
      tagline: 'One last favor, my trusted friend...',
      attack: 'royalSeal',
      color: '#ffd24a',
      accent: '#b21b1b',
      size: { w: 96, h: 96 },
      speed: 1.4
    }
  };
  const PRINCE_PAL32 = {
    ".": null,
    "k": "#0b0f12",
    "b": "#0e1720",
    "C": "#ffd24a",
    "c": "#e6b93f",
    "J": "#ff3a3a",
    "j": "#ff9f9f",
    "S": "#f5cc66",
    "s": "#e1b652",
    "o": "#b88f33",
    "e": "#f2f7ff",
    "n": "#11151a",
    "g": "#18a261",
    "G": "#0f6f41",
    "r": "#ffdf6b",
    "R": "#caa23b",
    "w": "#ffffff",
    "W": "#e6eef6",
    "E": "#4b5663",
    "d": "#d32b2b",
    "D": "#b31f1f"
  };

  const PRINCE32_IDLE_A = [
    "..kk..CCCCCCCC..kk..............",
    ".kkCJJCCCCCCCCJJCkk.............",
    ".kCCCCCCCCCCCCCCCCk.............",
    "..kCCCcCCCCCCCCcCCk.............",
    "...kkk..kkkkkk..kkk.............",
    "...k..sSSSSSSSSs..k.............",
    "..k.sSSssssssssSSs.k............",
    "..k.sSse..nn..eSsS.k............",
    "..k.sSSssssssssSSs.k............",
    "..k..sSSSSSSSSSSs..k............",
    "...k..sooooooooS..k.............",
    "...k...sooooooS...k.............",
    "...kk...soooos...kk.............",
    "....kk...ssss...kk..............",
    ".....kRk......kRk...............",
    "...kkggggggggggggkk.............",
    "..kgGGgggggggggggGGgk...........",
    ".kgGgGRrrrrrrrrRGgGgk...........",
    ".kgGgGRrwwEwwrRGgGgk............",
    ".kgGgGRrWwEwWrRGgGgk............",
    ".kgGgGRrrrrrrrrRGgGgk............",
    ".kgGGggGGgggggggGGgk.............",
    "..kggggggggggggggggk............",
    "...kkGggggggGGgggkk.............",
    "....kGGGGGGGGGGGGGk.............",
    ".....kGGGGGGGGGGGk..............",
    "......kGGGGGGGGGk...............",
    ".......kkkkkkkkk................",
    "........k.....k.................",
    "........k.....k.................",
    ".........kkkkk..................",
    "................................"
  ];

  const PRINCE32_IDLE_B = [
    "..kk..CCCCCCCC..kk..............",
    ".kkCjJCCCCCCCCJjCkk.............",
    ".kCCCCCCCCCCCCCCCCk.............",
    "..kCCCcCCCCCCCCcCCk.............",
    "...kkk..kkkkkk..kkk.............",
    "...k..sSSSSSSSSs..k.............",
    "..k.sSSssssssssSSs.k............",
    "..k.sSse..nn..eSsS.k............",
    "..k.sSSssssssssSSs.k............",
    "..k..sSSSSSSSSSSs..k............",
    "...k..sooooooooS..k.............",
    "...k...sooooooS...k.............",
    "...kk...soooos...kk.............",
    "....kk...ssss...kk..............",
    ".....kRk......kRk...............",
    "...kkggggGGggggggkk.............",
    "..kgGGgggggggggggGGgk...........",
    ".kgGgGRrrrrrrrrRGgGgk...........",
    ".kgGgGRrWwEwWrRGgGgk............",
    ".kgGgGRrwwEwwrRGgGgk............",
    ".kgGgGRrrrrrrrrRGgGgk............",
    ".kgGGgggggggggggGGgk.............",
    "..kggggggggggggggggk............",
    "...kkGggggggGGgggkk.............",
    "....kGGGGGGGGGGGGGk.............",
    ".....kGGGGGGGGGGGk..............",
    "......kGGGGGGGGGk...............",
    ".......kkkkkkkkk................",
    "........k.....k.................",
    "........k.....k.................",
    ".........kkkkk..................",
    "................................"
  ];

  const PRINCE32_HURT = [
    "..kk..CCCCCCCC..kk..............",
    ".kkCJJCCCCCCCCJJCkk.............",
    ".kCCCCCCCCCCCCCCCCk.............",
    "..kCCCcCCCCCCCCcCCk.............",
    "...kkk..kbbbbk..kkk.............",
    "...k..sSSSSSSSSs..k.............",
    "..k.SSSSSssssSSSS.k............",
    "..k.sSse..nn..eSsS.k............",
    "..k.SSSSSssssSSSS.k............",
    "..k..sSSSSSSSSSSs..k............",
    "...k..sooooooooS..k.............",
    "...k...sooooooS...k.............",
    "...kk...soooos...kk.............",
    "....kk...ssss...kk..............",
    ".....kRk......kRk...............",
    "...kkggggggggggggkk.............",
    "..kgGGgggggggggggGGgk...........",
    ".kgGgGRrRRRRRRrRGgGgk...........",
    ".kgGgGRrWwEwWrRGgGgk............",
    ".kgGgGRrwwEwwrRGgGgk............",
    ".kgGgGRrRRRRRRrRGgGgk............",
    ".kgGGgggggggggggGGgk.............",
    "..kggGGgggggggggGGgk............",
    "...kkGggggggGGgggkk.............",
    "....kGGGGGGGGGGGGGk.............",
    ".....kGGGGGGGGGGGk..............",
    "......kGGGGGGGGGk...............",
    ".......kkkkkkkkk................",
    "........k.....k.................",
    "........k.....k.................",
    ".........kkkkk..................",
    "................................"
  ];

  const SEAL_PAL = {
    ".": null, "#": "#1b1f24",
    "w": "#ffffff", "W": "#e6eef6",
    "g": "#ffd24a", "G": "#e0b83e",
    "r": "#d32b2b", "R": "#b31f1f"
  };
  const SEAL_A = [
    "..RRRR..",
    ".RrrrrR.",
    "RrRGGrrR",
    "RrG##GrR",
    "RrG##GrR",
    "RrRGGrrR",
    ".RrrrrR.",
    "..RRRR.."
  ];
  const SEAL_B = [
    "..RRRR..",
    ".RrrrrR.",
    "RrRGGrrR",
    "RrG#wGrR",
    "RrG#wGrR",
    "RrRGGrrR",
    ".RrrrrR.",
    "..RRRR.."
  ];

  function drawSpriteCharMap(ctx, sprite, pal, x, y, scale = 3){
    const px = scale|0;
    for (let r = 0; r < sprite.length; r++){
      const row = sprite[r];
      for (let c = 0; c < row.length; c++){
        const color = pal[row[c]];
        if (!color) continue;
        ctx.fillStyle = color;
        ctx.fillRect((x|0) + c*px, (y|0) + r*px, px, px);
      }
    }
  }
  function getPrinceFrame32(animTimeMs, hurtTimerMs = 0){
    if (hurtTimerMs > 0) return PRINCE32_HURT;
    return (Math.floor(animTimeMs / 160) % 2 === 0) ? PRINCE32_IDLE_A : PRINCE32_IDLE_B;
  }
  function renderPrinceBoss32(ctx, boss, animTimeMs, hurtTimerMs = 0, scale = 3){
    const frame = getPrinceFrame32(animTimeMs, hurtTimerMs);
    const sprW = frame[0].length * scale;
    const sprH = frame.length * scale;
    const sx = Math.round(boss.x + (boss.w - sprW)/2);
    const sy = Math.round(boss.y + (boss.h - sprH)/2);
    drawSpriteCharMap(ctx, frame, PRINCE_PAL32, sx, sy, scale);
  }

  function createRoyalSeal(x, y, vx, vy){
    return { x, y, vx, vy, w: 8, h: 8, t: 0, kind: 'royalSeal' };
  }
  function drawRoyalSeal(ctx, seal, scale = 2){
    const frame = (Math.floor(seal.t / 120) % 2 === 0) ? SEAL_A : SEAL_B;
    const px = scale|0;
    for (let r=0;r<frame.length;r++){
      const row = frame[r];
      for (let c=0;c<row.length;c++){
        const ch = row[c];
        const color = SEAL_PAL[ch];
        if (!color) continue;
        ctx.fillStyle = color;
        ctx.fillRect((seal.x|0) + c*px, (seal.y|0) + r*px, px, px);
      }
    }
  }

  function spawnPrinceDeathBurst(cx, cy, scale = 3){
    const rng = Math.random;
    const shards = [];
    const confetti = [];
    const pushPix = (arr, color, dx, dy, life, size=2) =>
      arr.push({ x: cx, y: cy, vx: dx, vy: dy, a: 1, life, size, color });
    for (let i=0;i<16;i++){
      const ang = (i/16)*Math.PI*2 + (rng()*0.4-0.2);
      const spd = 1.8 + rng()*2.2;
      pushPix(shards, (i%2? '#ffd24a':'#e6b93f'), Math.cos(ang)*spd, Math.sin(ang)*spd, 450 + rng()*300, 2*scale/3);
    }
    for (let i=0;i<6;i++){
      const ang = rng()*Math.PI*2;
      const spd = 2 + rng()*2.8;
      pushPix(shards, (i%2? '#ff3a3a':'#ff9f9f'), Math.cos(ang)*spd, Math.sin(ang)*spd, 400 + rng()*300, 2*scale/3);
    }
    for (let i=0;i<14;i++){
      const ang = rng()*Math.PI*2;
      const spd = 1.2 + rng()*2.0;
      const color = ["#ffffff","#e6eef6","#ffd24a","#caa23b"][i%4];
      pushPix(confetti, color, Math.cos(ang)*spd, Math.sin(ang)*spd, 520 + rng()*320, scale);
    }
    return { shards, confetti, alive: true, t: 0 };
  }
  function updateDeathBurst(fx, dt){
    if (!fx || !fx.alive) return;
    fx.t += dt;
    const grav = 0.003 * dt;
    const damp = 0.998;
    let aliveCount = 0;
    for (const arr of [fx.shards, fx.confetti]){
      for (const p of arr){
        p.vy += grav;
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= damp;
        p.vy *= 0.999;
        p.life -= dt;
        p.a = Math.max(0, Math.min(1, p.life / 600));
        if (p.life > 0) aliveCount++;
      }
    }
    if (aliveCount === 0) fx.alive = false;
  }
  function drawDeathBurst(ctx, fx){
    if (!fx || !fx.alive) return;
    for (const p of fx.shards){
      if (p.life <= 0) continue;
      ctx.globalAlpha = p.a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x|0, p.y|0, p.size|0, p.size|0);
    }
    for (const p of fx.confetti){
      if (p.life <= 0) continue;
      ctx.globalAlpha = p.a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x|0, p.y|0, p.size|0, p.size|0);
    }
    ctx.globalAlpha = 1;
  }

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }
  function updateHearts(){
    if (!player) return;
    heartsEl.innerHTML = '';
    for (let i=0;i<playerBase.maxHP;i++){
      const d = document.createElement('div');
      d.className = 'life' + (i < player.hp ? '' : ' ghost');
      heartsEl.appendChild(d);
    }
  }
  function updateCapacity(){ capacityFill.style.transform = `scaleX(${clamp(inbox,0,1)})`; }
  function getCampaignEntry(level){
    const idx = Math.min(CAMPAIGN.length, Math.max(1, level)) - 1;
    return CAMPAIGN[idx];
  }
  function applyPalette(entry){
    if (!entry) return;
    const root = document.documentElement;
    root.style.setProperty('--accent', entry.palette[0]);
    root.style.setProperty('--danger', entry.palette[1]);
    root.style.setProperty('--gold', entry.palette[0]);
    document.body.style.background = `radial-gradient(circle at top, ${entry.palette[0]}22, #010203 68%)`;
  }
  function nextSubject(entry){
    if (!entry || !entry.subjects || !entry.subjects.length) return '';
    const idx = subjectCycle % entry.subjects.length;
    subjectCycle++;
    return entry.subjects[idx];
  }
  function updateLevelHUD(){
    const entry = currentEntry || getCampaignEntry(level);
    hudLevel.textContent = `LEVEL ${String(level).padStart(2,'0')} - ${entry.title.toUpperCase()}`;
  }
  function updateHighScore(){ hudHigh.textContent = String(highScore).padStart(5,'0'); }
  function setTicker(text){ if (tickerText) tickerText.innerHTML = text; }
  function addScore(n){
    score += n;
    hudScore.textContent = String(score).padStart(5,'0');
    if (score > highScore){
      highScore = score;
      updateHighScore();
      try { localStorage.setItem('spamInvadersHighScore', String(highScore)); } catch(err){}
    }
  }
  function showBossUI(r=1){ bossLabel.style.display='block'; bossBar.style.display='block'; bossFill.style.transform=`scaleX(${r})`; }
  function hideBossUI(){ bossLabel.style.display='none'; bossBar.style.display='none'; }

  function triggerGameOver(){
    if (state === 'gameover') return;
    clearBossIntro();
    state='gameover';
    setTicker('MAILBOX LOST  -  PRESS START TO TRY AGAIN');
    setTimeout(()=>elGameOver.style.display='flex',60);
  }
  function loseLife(){
    if (!player || state !== 'play') return;
    if (player.hp <= 0) return;
    player.hp--;
    updateHearts();
    enemyBullets = [];
    bullets = [];
    if (player.hp > 0){
      inbox = 1;
      updateCapacity();
      setTicker(`SHIELD REBOOTED  -  LIVES x${player.hp}`);
    } else {
      inbox = 0;
      updateCapacity();
      triggerGameOver();
    }
  }
  function damageInbox(amount){
    if (state !== 'play' || !player || player.hp <= 0) return;
    inbox = clamp(inbox - amount, 0, 1);
    updateCapacity();
    if (inbox <= 0){
      loseLife();
    }
  }
  function forceShieldBreak(){
    if (state !== 'play' || !player || player.hp <= 0) return;
    inbox = 0;
    updateCapacity();
    loseLife();
  }

  try {
    highScore = Number(localStorage.getItem('spamInvadersHighScore') || 0);
  } catch(err){
    highScore = 0;
  }
  updateHighScore();
  applyPalette(getCampaignEntry(1));
  setTicker('PRESS START  -  DEFEND THE INBOX');

  addEventListener('keydown', e => {
    if ((state === 'menu' || state === 'gameover') && (e.code === 'Enter' || e.code === 'Space')){
      e.preventDefault();
      startNewRun();
      return;
    }
    if (state === 'interstitial' && (e.code === 'Enter' || e.code === 'Space')){
      e.preventDefault();
      nextLevel();
      return;
    }
    keys[e.code] = true;
    if (e.code === 'Space') e.preventDefault();
  }, {passive:false});
  addEventListener('keyup', e => keys[e.code] = false);

  function getLevelParams(lvl){
    const entry = getCampaignEntry(lvl);
    switch(entry.id){
      case 1:
        return {
          rows: 4,
          cols: 7,
          enemyHPBackRow: 1,
          swarmDX: 0.32,
          dropY: 10,
          enemyFireBaseMs: 1150,
          bossHP: 60,
          bossSpeed: BOSSES[entry.boss].speed,
          behaviour: { flash:false, diagonalDrop:false, zigzag:false, courier:false }
        };
      case 2:
        return {
          rows: 5,
          cols: 8,
          enemyHPBackRow: 2,
          swarmDX: 0.58,
          dropY: 14,
          enemyFireBaseMs: 920,
          bossHP: 80,
          bossSpeed: BOSSES[entry.boss].speed,
          behaviour: { flash:true, diagonalDrop:true, zigzag:false, courier:false }
        };
      case 3:
        return {
          rows: 5,
          cols: 8,
          enemyHPBackRow: 2,
          swarmDX: 0.7,
          dropY: 14,
          enemyFireBaseMs: 780,
          bossHP: 100,
          bossSpeed: BOSSES[entry.boss].speed,
          behaviour: { flash:true, diagonalDrop:false, zigzag:true, zigzagAmp:8, zigzagSpeed:0.045, courier:false }
        };
      case 4:
      default:
        return {
          rows: 5,
          cols: 8,
          enemyHPBackRow: 3,
          swarmDX: 0.76,
          dropY: 16,
          enemyFireBaseMs: 720,
          bossHP: 120,
          bossSpeed: BOSSES[entry.boss].speed,
          behaviour: { flash:true, diagonalDrop:false, zigzag:false, courier:true }
        };
    }
  }

  function startNewRun(){
    elStart.style.display='none'; elCleared.style.display='none'; elGameOver.style.display='none';
    clearBossIntro();
    player = { x: W/2-20, y: H-40, w:playerBase.w, h:playerBase.h, speed:playerBase.speed, hp:playerBase.maxHP, cooldown:0, invuln:0 };
    bullets = [];
    enemyBullets = [];
    powerUps = [];
    score = 0;
    hudScore.textContent = '00000';
    inbox = 1.0;
    level = 1;
    subjectCycle = 0;
    currentEntry = getCampaignEntry(level);
    currentEntryId = currentEntry.id;
    applyPalette(currentEntry);
    currentSubject = nextSubject(currentEntry);
    updateLevelHUD();
    spawnWave(level);
    updateHearts();
    updateCapacity();
    boss = null;
    hideBossUI();
    princeFX = null;
    state='play';
    keys = {};
    setTicker(`LEVEL ${String(level).padStart(2,'0')} - ${currentEntry.title.toUpperCase()} - ${currentSubject.toUpperCase()}`);
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  function continueNextLevel(){
    inbox = clamp(inbox + 0.25, 0, 1);
    if (level % 2 === 0 && player.hp < playerBase.maxHP) player.hp++;
    updateHearts(); updateCapacity();

    elCleared.style.display='none';
    bullets=[]; enemyBullets=[]; powerUps = [];
    boss=null; hideBossUI();
    clearBossIntro();

    const entry = getCampaignEntry(level);
    if (!currentEntry || entry.id !== currentEntryId){ subjectCycle = 0; }
    currentEntry = entry;
    currentEntryId = entry.id;
    applyPalette(entry);
    currentSubject = nextSubject(entry);
    updateLevelHUD();

    spawnWave(level);
    state='play';
    keys = {};
    princeFX = null;
    setTicker(`LEVEL ${String(level).padStart(2,'0')} - ${entry.title.toUpperCase()} - ${currentSubject.toUpperCase()}`);
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  function spawnWave(lvl){
    currentEntry = currentEntry || getCampaignEntry(lvl);
    currentEntryId = currentEntry.id;
    const bossDef = BOSSES[currentEntry.boss] || BOSSES.prince;
    currentBossDef = bossDef;
    if (!currentSubject) currentSubject = nextSubject(currentEntry);
    powerUps = [];

    const p = getLevelParams(lvl);
    const behaviour = p.behaviour || {};
    const gapX = 6, gapY = 10;
    const ew = 34, eh = 20;
    const waveWidth = p.cols*ew + (p.cols-1)*gapX;
    const startX = Math.max(12, (W - waveWidth)/2);
    const startY = 46;
    const primary = currentEntry.palette[0];
    const secondary = currentEntry.palette[1];
    const list = [];
    for (let r=0;r<p.rows;r++){
      for (let c=0;c<p.cols;c++){
        const enemy = {
          x: startX + c*(ew+gapX),
          y: startY + r*(eh+gapY),
          baseY: startY + r*(eh+gapY),
          w: ew, h: eh,
          dir: 1,
          hp: 1 + (r>2?Math.min(1+p.enemyHPBackRow,3):0),
          color: (r % 2 === 0) ? primary : secondary,
          flash: behaviour.flash ? 0 : null,
          courier: behaviour.courier && r === 0 && (c % 2 === 0),
          diagTimer: behaviour.diagonalDrop ? 800 + Math.random()*800 : 0,
          diagDir: Math.random() < 0.5 ? -1 : 1,
          zigzagPhase: behaviour.zigzag ? Math.random()*Math.PI*2 : 0,
          zigzagAmp: behaviour.zigzagAmp || 0,
          zigzagSpeed: behaviour.zigzagSpeed || 0
        };
        list.push(enemy);
      }
    }
    swarm = {
      list,
      dx: p.swarmDX,
      dropY: p.dropY,
      leftBound: 12,
      rightBound: W-12,
      shootTimer: p.enemyFireBaseMs,
      fireBase: p.enemyFireBaseMs,
      behaviour,
      entry: currentEntry,
      subject: currentSubject,
      bossSpec: {
        hp: p.bossHP,
        speed: p.bossSpeed,
        kind: bossDef.id,
        name: bossDef.displayName,
        tagline: bossDef.tagline,
        color: bossDef.color,
        accent: bossDef.accent
      }
    };
  }

  function spawnBoss(spec){
    const def = BOSSES[spec.kind] || BOSSES.prince;
    currentBossDef = def;
    const size = def.size || { w: 180, h: 90 };
    boss = {
      x: W/2 - size.w/2,
      y: 68,
      w: size.w,
      h: size.h,
      dir: 1,
      maxHP: spec.hp,
      hp: spec.hp,
      fire: 0,
      speed: spec.speed,
      type: def.id,
      hurt: 0,
      name: def.displayName,
      color: spec.color || def.color,
      accent: spec.accent || def.accent,
      def
    };
    bossLabel.textContent = def.displayName;
    showBossUI(1);
    setTicker(`${def.displayName} - ${def.tagline}`);
  }

  function showBossIntro(spec){
    if (!spec) return;
    pendingBossSpec = spec;
    if (bossIntroTimeout){
      clearTimeout(bossIntroTimeout);
      bossIntroTimeout = null;
    }
    enemyBullets = [];
    bullets = [];
    const def = BOSSES[spec.kind] || BOSSES.prince;
    bossIntroTitle.textContent = def.displayName;
    bossIntroName.textContent = def.tagline;
    elBossIntro.style.display = 'flex';
    state = 'bossIntro';
    setTicker(`${def.displayName} - STAND BY`);
    bossIntroTimeout = setTimeout(() => {
      if (state !== 'bossIntro' || pendingBossSpec !== spec) return;
      elBossIntro.style.display = 'none';
      state = 'play';
      spawnBoss(spec);
      pendingBossSpec = null;
      bossIntroTimeout = null;
      requestAnimationFrame(loop);
    }, 1700);
  }

  function clearBossIntro(){
    if (bossIntroTimeout){
      clearTimeout(bossIntroTimeout);
      bossIntroTimeout = null;
    }
    elBossIntro.style.display = 'none';
    pendingBossSpec = null;
    if (state === 'bossIntro') state = 'play';
  }

  function shootPlayer(){
    if (player.cooldown <= 0){
      bullets.push({ x: player.x + player.w/2 - 2, y: player.y - 10, w:4, h:10, vy:-7 });
      player.cooldown = 12;
    }
  }
  function enemyTryShoot(dt){
    if (!swarm.list.length) return;
    swarm.shootTimer -= dt;
    if (swarm.shootTimer <= 0){
      const alive = swarm.list.length;
      const behaviour = swarm.behaviour || {};
      let rate = swarm.fireBase - alive * (behaviour.flash ? 12 : 8);
      rate = clamp(rate, 240, 1400);
      swarm.shootTimer = rate;

      const byCol = {};
      for (const e of swarm.list){
        const colKey = Math.round(e.x/48);
        if (!byCol[colKey] || e.y > byCol[colKey].y) byCol[colKey] = e;
      }
      const shooters = Object.values(byCol);
      if (shooters.length){
        const s = shooters[Math.floor(Math.random()*shooters.length)];
        if (behaviour.flash && s){ s.flash = 140; }
        const bulletColor = (swarm.entry && swarm.entry.palette[1]) || '#ff9a9a';
        const baseVy = 3.0 + Math.min(level*0.25, 3.4);
        if (behaviour.courier && s.courier){
          const seal = createRoyalSeal(s.x + s.w/2 - 4, s.y + s.h + 2, 0, baseVy);
          seal.scale = 1.5;
          enemyBullets.push(seal);
        } else if (swarm.entry && swarm.entry.id === 3){
          const offsets = [-1.4, 0, 1.4];
          offsets.forEach(off => {
            enemyBullets.push({
              x: s.x + s.w/2 - 3,
              y: s.y + s.h + 2,
              w:6, h:12,
              vy: baseVy + Math.random()*0.6,
              vx: off * 0.8,
              color: bulletColor,
              kind: 'spread'
            });
          });
        } else {
          enemyBullets.push({
            x: s.x + s.w/2 - 2,
            y: s.y + s.h + 2,
            w:4, h:10,
            vy: baseVy,
            vx: 0,
            color: bulletColor,
            kind: 'spam'
          });
        }
      }
    }
  }

  function drawHeartProjectile(ctx, proj){
    const size = proj.size || 12;
    const x = proj.x;
    const y = proj.y;
    ctx.fillStyle = proj.color || '#ff6ad5';
    ctx.beginPath();
    ctx.moveTo(x + size/2, y + size);
    ctx.bezierCurveTo(x + size, y + size*0.6, x + size*0.85, y, x + size*0.5, y + size*0.35);
    ctx.bezierCurveTo(x + size*0.15, y, x, y + size*0.6, x + size/2, y + size);
    ctx.fill();
  }

  function drawCoinProjectile(ctx, proj){
    const size = proj.size || 10;
    const radius = size/2;
    const x = proj.x + radius;
    const y = proj.y + radius;
    ctx.fillStyle = proj.color || '#ffd24a';
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#1b1f24';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y, radius * 0.6, 0, Math.PI*2);
    ctx.stroke();
  }

  function drawPhishProjectile(ctx, proj){
    const w = proj.w || 10;
    const h = proj.h || 12;
    const x = proj.x;
    const y = proj.y;
    ctx.fillStyle = '#fff2dd';
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = proj.color || '#ff8a33';
    ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.moveTo(x, y);
    ctx.lineTo(x + w/2, y + h/2);
    ctx.lineTo(x + w, y);
    ctx.stroke();
  }

  function drawSpreadProjectile(ctx, proj){
    const w = proj.w || 6;
    const h = proj.h || 12;
    const x = proj.x;
    const y = proj.y;
    ctx.fillStyle = proj.color || '#ff00aa';
    ctx.beginPath();
    ctx.moveTo(x + w/2, y);
    ctx.lineTo(x + w, y + h/2);
    ctx.lineTo(x + w/2, y + h);
    ctx.lineTo(x, y + h/2);
    ctx.closePath();
    ctx.fill();
  }

  function spawnVPNPowerUp(x, y){
    powerUps.push({ x: x - 10, y, w: 20, h: 12, vy: 1.5, glow: 0, type: 'vpn' });
  }

  function updatePowerUps(dt, frameScale){
    powerUps = powerUps.filter(p => {
      p.y += p.vy * frameScale;
      p.glow = (p.glow + dt * 0.01) % (Math.PI * 2);
      if (p.y > H + 24) return false;
      if (player && player.hp > 0 && rectsOverlap(p, player) && (player.invuln || 0) <= 0){
        inbox = clamp(inbox + 0.6, 0, 1);
        updateCapacity();
        player.invuln = Math.max(player.invuln || 0, 1800);
        setTicker('VPN SHIELD ONLINE  -  INBOX HARDENED');
        return false;
      }
      return true;
    });
  }

  function drawPowerUps(){
    for (const p of powerUps){
      const pulse = 0.6 + 0.3 * Math.sin(p.glow || 0);
      ctx.fillStyle = `rgba(120, 255, 230, ${pulse})`;
      ctx.beginPath();
      ctx.moveTo(p.x + p.w/2, p.y);
      ctx.lineTo(p.x + p.w, p.y + p.h/2);
      ctx.lineTo(p.x + p.w/2, p.y + p.h);
      ctx.lineTo(p.x, p.y + p.h/2);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = 'rgba(20,60,70,0.8)';
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#000';
  }

  function bossFire(dt){
    if (!boss) return;
    boss.fire -= dt;
    if (boss.fire <= 0){
      const cx = boss.x + boss.w/2;
      const cy = boss.y + boss.h;
      const def = boss.def || BOSSES.prince;
      let cooldown = clamp(420 - level*20, 240, 520);
      switch(def.attack){
        case 'heartFan': {
          const offsets = [-1.5, -0.8, 0, 0.8, 1.5];
          offsets.forEach((off, i) => {
            enemyBullets.push({
              x: cx - 6,
              y: cy - 6,
              size: 14,
              w:14, h:14,
              vx: off * 1.2,
              vy: 3.2 + i*0.05,
              kind: 'heart',
              color: def.color
            });
          });
          cooldown = 520;
          break;
        }
        case 'aimedShot': {
          if (player){
            const px = player.x + player.w/2;
            const py = player.y + player.h/2;
            const dx = px - cx;
            const dy = py - cy;
            const mag = Math.hypot(dx, dy) || 1;
            const speed = 4.4;
            enemyBullets.push({
              x: cx - 4,
              y: cy - 6,
              w:8, h:14,
              vx: (dx / mag) * speed,
              vy: (dy / mag) * speed,
              kind: 'phish',
              color: def.color
            });
          }
          cooldown = 440;
          break;
        }
        case 'coinRain': {
          const streams = 6;
          for (let i=0;i<streams;i++){
            const offset = (i/(streams-1) - 0.5) * (boss.w - 20);
            enemyBullets.push({
              x: boss.x + boss.w/2 + offset,
              y: cy - 4,
              size: 12,
              w:12, h:12,
              vx: (Math.random()-0.5) * 0.6,
              vy: 3.4 + Math.random()*0.8,
              kind: 'coin',
              color: def.color
            });
          }
          cooldown = 500;
          break;
        }
        case 'royalSeal': {
          const base = 3.6 + Math.min(level*0.15, 2);
          const startY = boss.y + boss.h - 6;
          const spawnSeal = (vx) => {
            const seal = createRoyalSeal(cx - 4, startY, vx, base);
            seal.scale = 2;
            enemyBullets.push(seal);
          };
          spawnSeal(0);
          spawnSeal(-1.1);
          spawnSeal(1.1);
          cooldown = clamp(420 - level*18, 260, 420);
          break;
        }
        default: {
          const base = 3.4 + Math.min(level*0.1, 1.5);
          enemyBullets.push({x:cx-2, y:cy, w:4, h:10, vy: base, vx:0, color:def.color, kind:'spam'});
          enemyBullets.push({x:cx-2, y:cy, w:4, h:10, vy: base, vx:-1.4, color:def.color, kind:'spam'});
          enemyBullets.push({x:cx-2, y:cy, w:4, h:10, vy: base, vx:1.4, color:def.color, kind:'spam'});
        }
      }
      boss.fire = cooldown;
    }
  }

  function loop(t){
    const dt = Math.min(50, t-lastTime); lastTime = t;
    if (state!=='play'){
      updateDeathBurst(princeFX, dt);
      if (princeFX && !princeFX.alive) princeFX = null;
      if (princeFX && princeFX.alive){
        render();
        requestAnimationFrame(loop);
      }
      return;
    }
    const frameScale = dt / 16.67;

    if (keys['ArrowLeft'])  player.x -= player.speed * frameScale;
    if (keys['ArrowRight']) player.x += player.speed * frameScale;
    if (keys['Space']) shootPlayer();
    player.cooldown = Math.max(0, player.cooldown - frameScale);
    player.x = clamp(player.x, 8, W-8-player.w);

    for (const b of bullets) b.y += b.vy * frameScale;
    bullets = bullets.filter(b => b.y + b.h > 0);

    for (const eb of enemyBullets){
      eb.y += eb.vy * frameScale;
      eb.x += (eb.vx || 0) * frameScale;
      if (eb.kind === 'royalSeal') eb.t = (eb.t || 0) + dt;
      if (eb.y > H-40){
        damageInbox(0.02);
        eb.y = H+999;
      }
    }
    enemyBullets = enemyBullets.filter(eb => eb.y < H+20);

    if (swarm.list.length){
      const behaviour = swarm.behaviour || {};
      let hitEdge = false;
      for (const e of swarm.list){
        if (behaviour.zigzag){
          e.zigzagPhase += (e.zigzagSpeed || 0.045) * dt;
          e.y = e.baseY + Math.sin(e.zigzagPhase) * (e.zigzagAmp || 6);
        }
        e.x += swarm.dx * e.dir * frameScale;
        if (behaviour.diagonalDrop){
          e.diagTimer -= dt;
          if (e.diagTimer <= 0){
            e.diagTimer = 900 + Math.random()*900;
            e.x += 16 * e.diagDir;
            e.y += swarm.dropY;
            e.baseY += swarm.dropY;
          }
        }
        if (e.flash && e.flash > 0){
          e.flash = Math.max(0, e.flash - dt);
        }
        e.x = clamp(e.x, swarm.leftBound, swarm.rightBound - e.w);
        if (e.x < swarm.leftBound || e.x + e.w > swarm.rightBound) hitEdge = true;
      }
      if (hitEdge){
        for (const e of swarm.list){
          e.dir *= -1;
          e.y += swarm.dropY;
          e.baseY += swarm.dropY;
          if (behaviour.zigzag){
            e.baseY = e.y;
          }
          if (e.y + e.h >= player.y){
            damageInbox(0.12);
          }
        }
      }
      enemyTryShoot(dt);
    } else if (!boss && !pendingBossSpec){
      showBossIntro(swarm.bossSpec);
    }

    if (boss){
      boss.x += boss.speed * boss.dir * frameScale;
      if (boss.x < 16 || boss.x + boss.w > W-16) boss.dir *= -1;
      bossFire(dt);
      bossFill.style.transform = `scaleX(${boss.hp/boss.maxHP})`;
      boss.hurt = Math.max(0, (boss.hurt || 0) - dt);
    }

    if (swarm.list.length && player.hp > 0){
      for (const e of swarm.list){
        if (rectsOverlap(e, player)){
          forceShieldBreak();
          break;
        }
      }
    }
    if (boss && player.hp > 0 && rectsOverlap(boss, player)){
      forceShieldBreak();
    }

    for (const b of bullets){
      for (const e of swarm.list){
        if (rectsOverlap(b,e)){
          e.hp--; b.y = -9999;
          if (e.hp<=0){ e.dead = true; addScore(20); }
        }
      }
      if (boss && rectsOverlap(b,boss)){
        boss.hp--; b.y = -9999;
        boss.hurt = 160;
        addScore(5);
      }
    }
    swarm.list = swarm.list.filter(e => !e.dead);

    for (const eb of enemyBullets){
      if (rectsOverlap(eb, player)){
        eb.y = H+999;
        damageInbox(0.34);
      }
    }
    if (boss && boss.hp <= 0){
      clearBossIntro();
      const defeatedBoss = boss;
      if (defeatedBoss.type === 'prince'){
        princeFX = spawnPrinceDeathBurst(defeatedBoss.x + defeatedBoss.w/2, defeatedBoss.y + defeatedBoss.h/2, 3);
      }
      boss=null; hideBossUI();
      state='interstitial';
      elCleared.querySelector('h1').textContent = `[ INBOX SECURED ]`;
      elCleared.querySelector('p').textContent = 'The Prince has been unsubscribed. System rebooting..';
      elCleared.style.display='flex';
      setTicker('INBOX SECURED  -  SYSTEM REBOOTING');
      const currentLevel = level;
      setTimeout(()=>{
        if (state==='interstitial' && currentLevel===level){
          nextLevel();
        }
      }, 1500);
      return;
    }

    updateDeathBurst(princeFX, dt);
    if (princeFX && !princeFX.alive) princeFX = null;

    render();
    requestAnimationFrame(loop);
  }

  function nextLevel(){
    elCleared.style.display='none';
    level++;
    continueNextLevel();
  }

  function clear(){ ctx.fillStyle='#020409'; ctx.fillRect(0,0,W,H); }
  function drawPlayer(){
    ctx.fillStyle = '#6dff97';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x+player.w/2-3, player.y-6, 6, 6);
  }
  function drawSwarm(){
    for (const e of swarm.list){
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x, e.y, e.w, e.h);
      ctx.fillStyle = 'rgba(0,0,0,.25)';
      ctx.fillRect(e.x+3, e.y+3, e.w-6, e.h-6);
    }
  }
  function drawBoss(animTime){
    if (!boss) return;
    if (boss.type === 'prince'){
      renderPrinceBoss32(ctx, boss, animTime, boss.hurt || 0, 3);
    } else {
      ctx.fillStyle = 'rgba(255,223,75,1)';
      ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
      ctx.fillStyle = '#000';
      ctx.fillRect(boss.x + boss.w/2 - 30, boss.y - 12, 60, 12);
      for (let i=0;i<5;i++){
        ctx.beginPath();
        ctx.moveTo(boss.x + boss.w/2 - 26 + i*13, boss.y - 12);
        ctx.lineTo(boss.x + boss.w/2 - 20 + i*13, boss.y - 24);
        ctx.lineTo(boss.x + boss.w/2 - 14 + i*13, boss.y - 12);
        ctx.closePath(); ctx.fill();
      }
    }
  }
  function drawBullets(){ ctx.fillStyle='#ff6b6b'; for (const b of bullets) ctx.fillRect(b.x,b.y,b.w,b.h); }
  function drawEnemyBullets(){
    ctx.fillStyle='#9ad0ff';
    for (const eb of enemyBullets){
      if (eb.kind === 'royalSeal'){
        drawRoyalSeal(ctx, eb, eb.scale || 2);
      } else {
        ctx.fillRect(eb.x,eb.y,eb.w,eb.h);
      }
    }
  }
  function render(){
    clear();
    const animTime = performance.now();
    drawSwarm();
    drawBoss(animTime);
    drawEnemyBullets();
    drawBullets();
    drawPlayer();
    if (princeFX && princeFX.alive) drawDeathBurst(ctx, princeFX);
    ctx.fillStyle='rgba(109,255,151,.1)';
    ctx.fillRect(0, player.y+player.h+2, W, 1);
  }
})();
</script>
</body>
</html>
