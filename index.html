<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spam Invaders</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#090b10; --ink:#d6ffdf; --accent:#6dff97; --danger:#ff6666; --gold:#ffdf4b;
  }
  *{box-sizing:border-box}
  html,body{height:100%; overflow:hidden;}
  body{
    margin:0; display:grid; place-items:center; background:#010203;
    color:var(--ink); font-family:'Press Start 2P', 'Courier New', monospace; letter-spacing:.9px;
  }
  .frame{
    position:relative; width:388px; height:576px; max-width:96vw; background:#05070b;
    border:2px solid rgba(109,255,151,.5); box-shadow:0 0 23px rgba(109,255,151,.15), inset 0 0 36px rgba(109,255,151,.06);
    overflow:hidden; border-radius:7px;
  }
  .frame::after{
    content:"";position:absolute;inset:0;pointer-events:none;
    background:repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 2px, transparent 2px 6px);
    mix-blend-mode:soft-light;
  }
  header,footer{position:absolute;left:0;right:0;z-index:3;display:flex;align-items:center;padding:12px 14px}
  header{
    bottom:0; top:auto; background:linear-gradient(to top, rgba(0,0,0,.8), rgba(0,0,0,.0)); gap:18px; flex-wrap:wrap; justify-content:space-between;
  }
  footer{
    top:0; bottom:auto; background:linear-gradient(to bottom, rgba(0,0,0,.75), rgba(0,0,0,.0)); justify-content:center; font-size:8px; text-transform:uppercase;
  }
  .hudBlock{
    display:flex; flex-direction:column; gap:6px; min-width:96px; flex:1 1 0;
  }
  .hudLabel{
    font-size:8px; color:rgba(109,255,151,.65);
  }
  .hudValue{
    font-size:14px; color:var(--ink);
  }
  .hudTight{min-width:auto; flex:0 0 auto;}
  .gauge{
    position:relative; width:115px; height:9px; border:1px solid rgba(109,255,151,.45); background:rgba(109,255,151,.08);
  }
  .gauge i{
    position:absolute; inset:1px; background:linear-gradient(90deg,var(--accent),#9bffbc); transform-origin:left center;
  }
  .lives{
    display:flex; gap:5px;
  }
  .life{
    width:12px; height:9px; background:var(--accent); box-shadow:0 0 4px rgba(109,255,151,.4);
  }
  .ghost{opacity:.2}
  canvas{
    position:absolute; top:58px; left:16px; width:357px; height:461px; background:#020409; z-index:1;
    image-rendering:pixelated;
  }
  footer .tickerLabel{
    margin-right:12px; color:rgba(109,255,151,.65);
  }
  footer .tickerText{
    animation:tickerBlink 1.4s steps(2,end) infinite;
  }
  @keyframes tickerBlink{0%,49%{opacity:.18}50%,100%{opacity:1}}
  @keyframes alertFlash{0%,45%{opacity:1}55%,100%{opacity:.2}}
  .overlay{
    position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
    background:rgba(0,0,0,.9); z-index:5; text-align:center; padding:20px; text-transform:uppercase; gap:12px;
  }
  .overlay h1{color:var(--accent);margin:0;font-size:14px;}
  .overlay p{max-width:360px;color:#bce2c6;margin:0;font-size:8px;line-height:1.6;}
  .overlay-boss h1{color:var(--danger);font-size:16px;animation:alertFlash .6s steps(2,end) infinite;}
  .overlay-boss p{font-size:10px;color:var(--accent);letter-spacing:1px;}
  .btn{
    display:inline-block; padding:9px 14px; background:transparent; color:var(--accent); border:2px solid var(--accent);
    border-radius:0; font-size:9px; cursor:pointer; box-shadow:0 0 9px rgba(109,255,151,.4); text-transform:uppercase; letter-spacing:1.4px;
  }
  .btn:hover{background:rgba(109,255,151,.25); color:#041b0b;}
  .bossbar{
    position:absolute; left:14px; right:14px; top:54px; height:9px; z-index:4;
    border:1px solid rgba(255,223,75,.45); border-radius:6px; overflow:hidden; background:rgba(255,223,75,.08); display:none;
  }
  .bossbar i{
    display:block; height:100%; background:linear-gradient(90deg,var(--gold),#ffeaa0); transform-origin:left center;
  }
  .bosslabel{
    position:absolute; top:42px; left:14px; z-index:4; font-size:7px; color:#ffe07e; text-shadow:0 0 5px rgba(255,223,75,.35); display:none;
  }
</style>
</head>
<body>
  <div class="frame">
    <header class="hud">
      <div class="hudBlock">
        <span class="hudLabel">Score</span>
        <span class="hudValue" id="hudScore">00000</span>
      </div>
      <div class="hudBlock">
        <span class="hudLabel">Hi-Score</span>
        <span class="hudValue" id="hudHigh">00000</span>
      </div>
      <div class="hudBlock hudTight">
        <span class="hudLabel">Level</span>
        <span class="hudValue" id="hudLevel">Wave 01</span>
      </div>
      <div class="hudBlock">
        <span class="hudLabel">Inbox Shield</span>
        <div class="gauge"><i id="capacityFill" style="transform:scaleX(1)"></i></div>
      </div>
      <div class="hudBlock hudTight">
        <span class="hudLabel">Lives</span>
        <div class="lives" id="hearts"></div>
      </div>
    </header>

    <div class="bosslabel" id="bossLabel">Nigerian Prince AI v7.x</div>
    <div class="bossbar" id="bossBar"><i id="bossFill" style="transform:scaleX(1)"></i></div>

    <canvas id="game" width="357" height="461"></canvas>

    <footer>
      <span class="tickerLabel">Command</span>
      <span class="tickerText">LEFT/RIGHT MOVE  -  SPACE FIRE  -  PRESS START</span>
    </footer>

    <!-- Start -->
    <div class="overlay" id="start">
      <h1>[ INSERT COIN ]</h1>
      <p>Sector mailbox under attack.<br>Deploy spam filters and defend the archive.</p>
      <button class="btn" id="btnStart">START</button>
    </div>

    <!-- Level Cleared -->
    <div class="overlay" id="cleared" style="display:none">
      <h1>[ INBOX SECURED ]</h1>
      <p>The Prince has been unsubscribed. System rebooting..</p>
      <button class="btn" id="btnNext">NEXT STAGE</button>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="gameover" style="display:none">
      <h1>[ MAILBOX BREACHED ]</h1>
      <p>Spam levels critical. Inbox overload. Systems throttled.</p>
      <button class="btn" id="btnAgain">TRY AGAIN</button>
    </div>

    <!-- Boss Intro -->
    <div class="overlay overlay-boss" id="bossIntro" style="display:none">
      <h1 id="bossIntroTitle">[ INCOMING THREAT ]</h1>
      <p id="bossIntroName">Nigerian Prince AI v7.x</p>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const hudLevel = document.getElementById('hudLevel');
  const capacityFill = document.getElementById('capacityFill');
  const bossBar = document.getElementById('bossBar');
  const bossFill = document.getElementById('bossFill');
  const bossLabel = document.getElementById('bossLabel');
  const hudScore = document.getElementById('hudScore');
  const hudHigh = document.getElementById('hudHigh');
  const heartsEl = document.getElementById('hearts');
  const tickerText = document.querySelector('.tickerText');

  const elStart = document.getElementById('start');
  const elCleared = document.getElementById('cleared');
  const elGameOver = document.getElementById('gameover');
  const elBossIntro = document.getElementById('bossIntro');
  const bossIntroTitle = document.getElementById('bossIntroTitle');
  const bossIntroName = document.getElementById('bossIntroName');

  document.getElementById('btnStart').onclick = () => startNewRun();
  document.getElementById('btnNext').onclick  = () => nextLevel();
  document.getElementById('btnAgain').onclick = () => startNewRun();

  let keys = {};
  let state = 'menu';
  const playerBase = { w:40, h:12, speed:5, maxHP:3 };
  let player, bullets, enemyBullets, boss, score, level, inbox;
  let swarm;
  let lastTime = 0;
  let highScore = 0;
  let princeFX = null;
  let pendingBossSpec = null;
  let bossIntroTimeout = null;

  const PRINCE_PAL32 = {
    ".": null,
    "k": "#0b0f12",
    "b": "#0e1720",
    "C": "#ffd24a",
    "c": "#e6b93f",
    "J": "#ff3a3a",
    "j": "#ff9f9f",
    "S": "#f5cc66",
    "s": "#e1b652",
    "o": "#b88f33",
    "e": "#f2f7ff",
    "n": "#11151a",
    "g": "#18a261",
    "G": "#0f6f41",
    "r": "#ffdf6b",
    "R": "#caa23b",
    "w": "#ffffff",
    "W": "#e6eef6",
    "E": "#4b5663",
    "d": "#d32b2b",
    "D": "#b31f1f"
  };

  const PRINCE32_IDLE_A = [
    "..kk..CCCCCCCC..kk..............",
    ".kkCJJCCCCCCCCJJCkk.............",
    ".kCCCCCCCCCCCCCCCCk.............",
    "..kCCCcCCCCCCCCcCCk.............",
    "...kkk..kkkkkk..kkk.............",
    "...k..sSSSSSSSSs..k.............",
    "..k.sSSssssssssSSs.k............",
    "..k.sSse..nn..eSsS.k............",
    "..k.sSSssssssssSSs.k............",
    "..k..sSSSSSSSSSSs..k............",
    "...k..sooooooooS..k.............",
    "...k...sooooooS...k.............",
    "...kk...soooos...kk.............",
    "....kk...ssss...kk..............",
    ".....kRk......kRk...............",
    "...kkggggggggggggkk.............",
    "..kgGGgggggggggggGGgk...........",
    ".kgGgGRrrrrrrrrRGgGgk...........",
    ".kgGgGRrwwEwwrRGgGgk............",
    ".kgGgGRrWwEwWrRGgGgk............",
    ".kgGgGRrrrrrrrrRGgGgk............",
    ".kgGGggGGgggggggGGgk.............",
    "..kggggggggggggggggk............",
    "...kkGggggggGGgggkk.............",
    "....kGGGGGGGGGGGGGk.............",
    ".....kGGGGGGGGGGGk..............",
    "......kGGGGGGGGGk...............",
    ".......kkkkkkkkk................",
    "........k.....k.................",
    "........k.....k.................",
    ".........kkkkk..................",
    "................................"
  ];

  const PRINCE32_IDLE_B = [
    "..kk..CCCCCCCC..kk..............",
    ".kkCjJCCCCCCCCJjCkk.............",
    ".kCCCCCCCCCCCCCCCCk.............",
    "..kCCCcCCCCCCCCcCCk.............",
    "...kkk..kkkkkk..kkk.............",
    "...k..sSSSSSSSSs..k.............",
    "..k.sSSssssssssSSs.k............",
    "..k.sSse..nn..eSsS.k............",
    "..k.sSSssssssssSSs.k............",
    "..k..sSSSSSSSSSSs..k............",
    "...k..sooooooooS..k.............",
    "...k...sooooooS...k.............",
    "...kk...soooos...kk.............",
    "....kk...ssss...kk..............",
    ".....kRk......kRk...............",
    "...kkggggGGggggggkk.............",
    "..kgGGgggggggggggGGgk...........",
    ".kgGgGRrrrrrrrrRGgGgk...........",
    ".kgGgGRrWwEwWrRGgGgk............",
    ".kgGgGRrwwEwwrRGgGgk............",
    ".kgGgGRrrrrrrrrRGgGgk............",
    ".kgGGgggggggggggGGgk.............",
    "..kggggggggggggggggk............",
    "...kkGggggggGGgggkk.............",
    "....kGGGGGGGGGGGGGk.............",
    ".....kGGGGGGGGGGGk..............",
    "......kGGGGGGGGGk...............",
    ".......kkkkkkkkk................",
    "........k.....k.................",
    "........k.....k.................",
    ".........kkkkk..................",
    "................................"
  ];

  const PRINCE32_HURT = [
    "..kk..CCCCCCCC..kk..............",
    ".kkCJJCCCCCCCCJJCkk.............",
    ".kCCCCCCCCCCCCCCCCk.............",
    "..kCCCcCCCCCCCCcCCk.............",
    "...kkk..kbbbbk..kkk.............",
    "...k..sSSSSSSSSs..k.............",
    "..k.SSSSSssssSSSS.k............",
    "..k.sSse..nn..eSsS.k............",
    "..k.SSSSSssssSSSS.k............",
    "..k..sSSSSSSSSSSs..k............",
    "...k..sooooooooS..k.............",
    "...k...sooooooS...k.............",
    "...kk...soooos...kk.............",
    "....kk...ssss...kk..............",
    ".....kRk......kRk...............",
    "...kkggggggggggggkk.............",
    "..kgGGgggggggggggGGgk...........",
    ".kgGgGRrRRRRRRrRGgGgk...........",
    ".kgGgGRrWwEwWrRGgGgk............",
    ".kgGgGRrwwEwwrRGgGgk............",
    ".kgGgGRrRRRRRRrRGgGgk............",
    ".kgGGgggggggggggGGgk.............",
    "..kggGGgggggggggGGgk............",
    "...kkGggggggGGgggkk.............",
    "....kGGGGGGGGGGGGGk.............",
    ".....kGGGGGGGGGGGk..............",
    "......kGGGGGGGGGk...............",
    ".......kkkkkkkkk................",
    "........k.....k.................",
    "........k.....k.................",
    ".........kkkkk..................",
    "................................"
  ];

  const SEAL_PAL = {
    ".": null, "#": "#1b1f24",
    "w": "#ffffff", "W": "#e6eef6",
    "g": "#ffd24a", "G": "#e0b83e",
    "r": "#d32b2b", "R": "#b31f1f"
  };
  const SEAL_A = [
    "..RRRR..",
    ".RrrrrR.",
    "RrRGGrrR",
    "RrG##GrR",
    "RrG##GrR",
    "RrRGGrrR",
    ".RrrrrR.",
    "..RRRR.."
  ];
  const SEAL_B = [
    "..RRRR..",
    ".RrrrrR.",
    "RrRGGrrR",
    "RrG#wGrR",
    "RrG#wGrR",
    "RrRGGrrR",
    ".RrrrrR.",
    "..RRRR.."
  ];

  function drawSpriteCharMap(ctx, sprite, pal, x, y, scale = 3){
    const px = scale|0;
    for (let r = 0; r < sprite.length; r++){
      const row = sprite[r];
      for (let c = 0; c < row.length; c++){
        const color = pal[row[c]];
        if (!color) continue;
        ctx.fillStyle = color;
        ctx.fillRect((x|0) + c*px, (y|0) + r*px, px, px);
      }
    }
  }
  function getPrinceFrame32(animTimeMs, hurtTimerMs = 0){
    if (hurtTimerMs > 0) return PRINCE32_HURT;
    return (Math.floor(animTimeMs / 160) % 2 === 0) ? PRINCE32_IDLE_A : PRINCE32_IDLE_B;
  }
  function renderPrinceBoss32(ctx, boss, animTimeMs, hurtTimerMs = 0, scale = 3){
    const frame = getPrinceFrame32(animTimeMs, hurtTimerMs);
    const sprW = frame[0].length * scale;
    const sprH = frame.length * scale;
    const sx = Math.round(boss.x + (boss.w - sprW)/2);
    const sy = Math.round(boss.y + (boss.h - sprH)/2);
    drawSpriteCharMap(ctx, frame, PRINCE_PAL32, sx, sy, scale);
  }

  function createRoyalSeal(x, y, vx, vy){
    return { x, y, vx, vy, w: 8, h: 8, t: 0, kind: 'royalSeal' };
  }
  function drawRoyalSeal(ctx, seal, scale = 2){
    const frame = (Math.floor(seal.t / 120) % 2 === 0) ? SEAL_A : SEAL_B;
    const px = scale|0;
    for (let r=0;r<frame.length;r++){
      const row = frame[r];
      for (let c=0;c<row.length;c++){
        const ch = row[c];
        const color = SEAL_PAL[ch];
        if (!color) continue;
        ctx.fillStyle = color;
        ctx.fillRect((seal.x|0) + c*px, (seal.y|0) + r*px, px, px);
      }
    }
  }

  function spawnPrinceDeathBurst(cx, cy, scale = 3){
    const rng = Math.random;
    const shards = [];
    const confetti = [];
    const pushPix = (arr, color, dx, dy, life, size=2) =>
      arr.push({ x: cx, y: cy, vx: dx, vy: dy, a: 1, life, size, color });
    for (let i=0;i<16;i++){
      const ang = (i/16)*Math.PI*2 + (rng()*0.4-0.2);
      const spd = 1.8 + rng()*2.2;
      pushPix(shards, (i%2? '#ffd24a':'#e6b93f'), Math.cos(ang)*spd, Math.sin(ang)*spd, 450 + rng()*300, 2*scale/3);
    }
    for (let i=0;i<6;i++){
      const ang = rng()*Math.PI*2;
      const spd = 2 + rng()*2.8;
      pushPix(shards, (i%2? '#ff3a3a':'#ff9f9f'), Math.cos(ang)*spd, Math.sin(ang)*spd, 400 + rng()*300, 2*scale/3);
    }
    for (let i=0;i<14;i++){
      const ang = rng()*Math.PI*2;
      const spd = 1.2 + rng()*2.0;
      const color = ["#ffffff","#e6eef6","#ffd24a","#caa23b"][i%4];
      pushPix(confetti, color, Math.cos(ang)*spd, Math.sin(ang)*spd, 520 + rng()*320, scale);
    }
    return { shards, confetti, alive: true, t: 0 };
  }
  function updateDeathBurst(fx, dt){
    if (!fx || !fx.alive) return;
    fx.t += dt;
    const grav = 0.003 * dt;
    const damp = 0.998;
    let aliveCount = 0;
    for (const arr of [fx.shards, fx.confetti]){
      for (const p of arr){
        p.vy += grav;
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= damp;
        p.vy *= 0.999;
        p.life -= dt;
        p.a = Math.max(0, Math.min(1, p.life / 600));
        if (p.life > 0) aliveCount++;
      }
    }
    if (aliveCount === 0) fx.alive = false;
  }
  function drawDeathBurst(ctx, fx){
    if (!fx || !fx.alive) return;
    for (const p of fx.shards){
      if (p.life <= 0) continue;
      ctx.globalAlpha = p.a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x|0, p.y|0, p.size|0, p.size|0);
    }
    for (const p of fx.confetti){
      if (p.life <= 0) continue;
      ctx.globalAlpha = p.a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x|0, p.y|0, p.size|0, p.size|0);
    }
    ctx.globalAlpha = 1;
  }

  const waveNames = [
    'Singles In Your Area',
    'You Won A Million Dollars',
    '5% Off Something Stupid',
    'Urgent Invoice Attached',
    'Crypto Goes 1000x Tonight',
    'Re: Re: Re: Final Notice',
    'Prince Requests Your Aid',
    'Free Vacation Voucher',
    'Guaranteed Weight Loss',
    'Exclusive NFT Opportunity'
  ];
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  function rectsOverlap(a,b){ return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y; }
  function updateHearts(){
    if (!player) return;
    heartsEl.innerHTML = '';
    for (let i=0;i<playerBase.maxHP;i++){
      const d = document.createElement('div');
      d.className = 'life' + (i < player.hp ? '' : ' ghost');
      heartsEl.appendChild(d);
    }
  }
  function updateCapacity(){ capacityFill.style.transform = `scaleX(${clamp(inbox,0,1)})`; }
  function getWaveName(lvl){
    return waveNames[(lvl-1) % waveNames.length] || `Wave ${lvl}`;
  }
  function updateLevelHUD(){
    hudLevel.textContent = `Wave ${String(level).padStart(2,'0')}`;
  }
  function updateHighScore(){ hudHigh.textContent = String(highScore).padStart(5,'0'); }
  function setTicker(text){ if (tickerText) tickerText.innerHTML = text; }
  function addScore(n){
    score += n;
    hudScore.textContent = String(score).padStart(5,'0');
    if (score > highScore){
      highScore = score;
      updateHighScore();
      try { localStorage.setItem('spamInvadersHighScore', String(highScore)); } catch(err){}
    }
  }
  function showBossUI(r=1){ bossLabel.style.display='block'; bossBar.style.display='block'; bossFill.style.transform=`scaleX(${r})`; }
  function hideBossUI(){ bossLabel.style.display='none'; bossBar.style.display='none'; }

  function triggerGameOver(){
    if (state === 'gameover') return;
    clearBossIntro();
    state='gameover';
    setTicker('MAILBOX LOST  -  PRESS START TO TRY AGAIN');
    setTimeout(()=>elGameOver.style.display='flex',60);
  }
  function loseLife(){
    if (!player || state !== 'play') return;
    if (player.hp <= 0) return;
    player.hp--;
    updateHearts();
    enemyBullets = [];
    bullets = [];
    if (player.hp > 0){
      inbox = 1;
      updateCapacity();
      setTicker(`SHIELD REBOOTED  -  LIVES x${player.hp}`);
    } else {
      inbox = 0;
      updateCapacity();
      triggerGameOver();
    }
  }
  function damageInbox(amount){
    if (state !== 'play' || !player || player.hp <= 0) return;
    inbox = clamp(inbox - amount, 0, 1);
    updateCapacity();
    if (inbox <= 0){
      loseLife();
    }
  }
  function forceShieldBreak(){
    if (state !== 'play' || !player || player.hp <= 0) return;
    inbox = 0;
    updateCapacity();
    loseLife();
  }

  try {
    highScore = Number(localStorage.getItem('spamInvadersHighScore') || 0);
  } catch(err){
    highScore = 0;
  }
  updateHighScore();
  setTicker('PRESS START  -  DEFEND THE INBOX');

  addEventListener('keydown', e => {
    if ((state === 'menu' || state === 'gameover') && (e.code === 'Enter' || e.code === 'Space')){
      e.preventDefault();
      startNewRun();
      return;
    }
    if (state === 'interstitial' && (e.code === 'Enter' || e.code === 'Space')){
      e.preventDefault();
      nextLevel();
      return;
    }
    keys[e.code] = true;
    if (e.code === 'Space') e.preventDefault();
  }, {passive:false});
  addEventListener('keyup', e => keys[e.code] = false);

  function getLevelParams(lvl){
    return {
      rows: clamp(4 + Math.floor(lvl/2), 4, 7),
      cols: 8,
      enemyHPBackRow: 1 + Math.floor(lvl/4),
      swarmDX: 0.4 + Math.min(0.04 * (lvl-1), 0.45),
      dropY: 12,
      enemyFireBaseMs: clamp(1100 - (lvl-1)*120, 350, 1100),
      bossHP: 50 + 10*lvl,
      bossSpeed: 1.4 + Math.min(0.15*(lvl-1), 2.2),
    };
  }

  function startNewRun(){
    elStart.style.display='none'; elCleared.style.display='none'; elGameOver.style.display='none';
    clearBossIntro();
    player = { x: W/2-20, y: H-40, w:playerBase.w, h:playerBase.h, speed:playerBase.speed, hp:playerBase.maxHP, cooldown:0 };
    bullets = [];
    enemyBullets = [];
    score = 0;
    hudScore.textContent = '00000';
    inbox = 1.0;
    level = 1;
    updateLevelHUD();
    spawnWave(level);
    updateHearts();
    updateCapacity();
    boss = null;
    hideBossUI();
    princeFX = null;
    state='play';
    keys = {};
    setTicker(`${getWaveName(level).toUpperCase()}  -  DEFEND THE INBOX`);
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  function continueNextLevel(){
    inbox = clamp(inbox + 0.25, 0, 1);
    if (level % 2 === 0 && player.hp < playerBase.maxHP) player.hp++;
    updateHearts(); updateCapacity();

    elCleared.style.display='none';
    bullets=[]; enemyBullets=[];
    boss=null; hideBossUI();
    clearBossIntro();

    spawnWave(level);
    state='play';
    keys = {};
    princeFX = null;
    setTicker(`${getWaveName(level).toUpperCase()}  -  DEFLECT ALL SPAM`);
    lastTime = performance.now();
    requestAnimationFrame(loop);
  }

  function spawnWave(lvl){
    const p = getLevelParams(lvl);
    const gapX=6, gapY=10;
    const ew=34, eh=20;
    const waveWidth = p.cols*ew + (p.cols-1)*gapX;
    const startX = Math.max(12, (W - waveWidth)/2);
    const startY = 46;
    const bossName = lvl === 1
      ? `Nigerian Prince AI v7.${Math.min(3 + lvl, 9)}`
      : `Spam Titan v${7 + lvl}.${Math.min(lvl, 9)}`;
    const list = [];
    for (let r=0;r<p.rows;r++){
      for (let c=0;c<p.cols;c++){
        list.push({
          x: startX + c*(ew+gapX),
          y: startY + r*(eh+gapY),
          w: ew, h: eh,
          dir: 1,
          hp: 1 + (r>2?Math.min(1+p.enemyHPBackRow,3):0),
          color: r<2 ? '#7ee7ff' : r<4 ? '#5fffb0' : '#f5f57a'
        });
      }
    }
    swarm = {
      list,
      dx: p.swarmDX,
      dropY: p.dropY,
      leftBound: 12,
      rightBound: W-12,
      shootTimer: p.enemyFireBaseMs,
      fireBase: p.enemyFireBaseMs,
      bossSpec: { hp: p.bossHP, speed: p.bossSpeed, type: lvl === 1 ? 'prince' : 'default', name: bossName }
    };
  }

  function spawnBoss(spec){
    const bossName = spec.name || (spec.type === 'prince'
      ? `Nigerian Prince AI v7.${Math.min(3 + level, 9)}`
      : `Spam Titan v${7 + level}.${Math.min(level,9)}`);
    if (spec.type === 'prince'){
      boss = { x: W/2-48, y: 68, w: 96, h: 96, dir: 1, maxHP: spec.hp, hp: spec.hp, fire: 0, speed: spec.speed, type: 'prince', hurt: 0, name: bossName };
    } else {
      boss = { x: W/2-100, y: 68, w: 200, h: 90, dir: 1, maxHP: spec.hp, hp: spec.hp, fire: 0, speed: spec.speed, type: 'default', hurt: 0, name: bossName };
    }
    bossLabel.textContent = bossName;
    showBossUI(1);
    setTicker('WARNING  -  BOSS SPAMMER DETECTED');
  }

  function showBossIntro(spec){
    if (!spec) return;
    pendingBossSpec = spec;
    if (bossIntroTimeout){
      clearTimeout(bossIntroTimeout);
      bossIntroTimeout = null;
    }
    enemyBullets = [];
    bullets = [];
    const displayName = spec.name || 'Unknown Threat';
    const bossName = displayName.toUpperCase();
    bossIntroTitle.textContent = '[ INCOMING THREAT ]';
    bossIntroName.textContent = displayName;
    elBossIntro.style.display = 'flex';
    state = 'bossIntro';
    setTicker(`${bossName}  -  STAND BY`);
    bossIntroTimeout = setTimeout(() => {
      if (state !== 'bossIntro' || pendingBossSpec !== spec) return;
      elBossIntro.style.display = 'none';
      state = 'play';
      spawnBoss(spec);
      pendingBossSpec = null;
      bossIntroTimeout = null;
      requestAnimationFrame(loop);
    }, 1700);
  }

  function clearBossIntro(){
    if (bossIntroTimeout){
      clearTimeout(bossIntroTimeout);
      bossIntroTimeout = null;
    }
    elBossIntro.style.display = 'none';
    pendingBossSpec = null;
    if (state === 'bossIntro') state = 'play';
  }

  function shootPlayer(){
    if (player.cooldown <= 0){
      bullets.push({ x: player.x + player.w/2 - 2, y: player.y - 10, w:4, h:10, vy:-7 });
      player.cooldown = 12;
    }
  }
  function enemyTryShoot(dt){
    if (!swarm.list.length) return;
    swarm.shootTimer -= dt;
    if (swarm.shootTimer <= 0){
      const alive = swarm.list.length;
      const rate = clamp(swarm.fireBase - alive*15, 220, 1200);
      swarm.shootTimer = rate;

      const byCol = {};
      for (const e of swarm.list){
        const colKey = Math.round(e.x/48);
        if (!byCol[colKey] || e.y > byCol[colKey].y) byCol[colKey] = e;
      }
      const shooters = Object.values(byCol);
      if (shooters.length){
        const s = shooters[Math.floor(Math.random()*shooters.length)];
        enemyBullets.push({ x: s.x + s.w/2 - 2, y: s.y + s.h + 2, w:4, h:10, vy: 3.0 + Math.min(level*0.2, 3) });
      }
    }
  }
  function bossFire(dt){
    if (!boss) return;
    boss.fire -= dt;
    if (boss.fire <= 0){
      boss.fire = clamp(420 - level*20, 220, 420);
      const cx = boss.x + boss.w/2;
      const base = 3.6 + Math.min(level*0.15, 2);
      if (boss.type === 'prince'){
        const startY = boss.y + boss.h - 6;
        const spawnSeal = (vx) => {
          const seal = createRoyalSeal(cx - 4, startY, vx, base);
          seal.scale = 2;
          enemyBullets.push(seal);
        };
        spawnSeal(0);
        spawnSeal(-1.1);
        spawnSeal(1.1);
      } else {
        enemyBullets.push({x:cx-2, y:boss.y+boss.h, w:4, h:10, vy: base});
        enemyBullets.push({x:cx-2, y:boss.y+boss.h, w:4, h:10, vy: base, vx:-1.2});
        enemyBullets.push({x:cx-2, y:boss.y+boss.h, w:4, h:10, vy: base, vx:1.2});
      }
    }
  }

  function loop(t){
    const dt = Math.min(50, t-lastTime); lastTime = t;
    if (state!=='play'){
      updateDeathBurst(princeFX, dt);
      if (princeFX && !princeFX.alive) princeFX = null;
      if (princeFX && princeFX.alive){
        render();
        requestAnimationFrame(loop);
      }
      return;
    }
    const frameScale = dt / 16.67;

    if (keys['ArrowLeft'])  player.x -= player.speed * frameScale;
    if (keys['ArrowRight']) player.x += player.speed * frameScale;
    if (keys['Space']) shootPlayer();
    player.cooldown = Math.max(0, player.cooldown - frameScale);
    player.x = clamp(player.x, 8, W-8-player.w);

    for (const b of bullets) b.y += b.vy * frameScale;
    bullets = bullets.filter(b => b.y + b.h > 0);

    for (const eb of enemyBullets){
      eb.y += eb.vy * frameScale;
      eb.x += (eb.vx || 0) * frameScale;
      if (eb.kind === 'royalSeal') eb.t = (eb.t || 0) + dt;
      if (eb.y > H-40){
        damageInbox(0.02);
        eb.y = H+999;
      }
    }
    enemyBullets = enemyBullets.filter(eb => eb.y < H+20);

    if (swarm.list.length){
      let hitEdge = false;
      for (const e of swarm.list){
        e.x += swarm.dx * e.dir * frameScale;
        if (e.x < swarm.leftBound || e.x + e.w > swarm.rightBound) hitEdge = true;
      }
      if (hitEdge){
        for (const e of swarm.list){
          e.dir *= -1;
          e.y += swarm.dropY;
          if (e.y + e.h >= player.y){
            damageInbox(0.12);
          }
        }
      }
      enemyTryShoot(dt);
    } else if (!boss && !pendingBossSpec){
      showBossIntro(swarm.bossSpec);
    }

    if (boss){
      boss.x += boss.speed * boss.dir * frameScale;
      if (boss.x < 16 || boss.x + boss.w > W-16) boss.dir *= -1;
      bossFire(dt);
      bossFill.style.transform = `scaleX(${boss.hp/boss.maxHP})`;
      boss.hurt = Math.max(0, (boss.hurt || 0) - dt);
    }

    if (swarm.list.length && player.hp > 0){
      for (const e of swarm.list){
        if (rectsOverlap(e, player)){
          forceShieldBreak();
          break;
        }
      }
    }
    if (boss && player.hp > 0 && rectsOverlap(boss, player)){
      forceShieldBreak();
    }

    for (const b of bullets){
      for (const e of swarm.list){
        if (rectsOverlap(b,e)){
          e.hp--; b.y = -9999;
          if (e.hp<=0){ e.dead = true; addScore(20); }
        }
      }
      if (boss && rectsOverlap(b,boss)){
        boss.hp--; b.y = -9999;
        boss.hurt = 160;
        addScore(5);
      }
    }
    swarm.list = swarm.list.filter(e => !e.dead);

    for (const eb of enemyBullets){
      if (rectsOverlap(eb, player)){
        eb.y = H+999;
        damageInbox(0.34);
      }
    }
    if (boss && boss.hp <= 0){
      clearBossIntro();
      const defeatedBoss = boss;
      if (defeatedBoss.type === 'prince'){
        princeFX = spawnPrinceDeathBurst(defeatedBoss.x + defeatedBoss.w/2, defeatedBoss.y + defeatedBoss.h/2, 3);
      }
      boss=null; hideBossUI();
      state='interstitial';
      elCleared.querySelector('h1').textContent = `[ INBOX SECURED ]`;
      elCleared.querySelector('p').textContent = 'The Prince has been unsubscribed. System rebooting..';
      elCleared.style.display='flex';
      setTicker('INBOX SECURED  -  SYSTEM REBOOTING');
      const currentLevel = level;
      setTimeout(()=>{
        if (state==='interstitial' && currentLevel===level){
          nextLevel();
        }
      }, 1500);
      return;
    }

    updateDeathBurst(princeFX, dt);
    if (princeFX && !princeFX.alive) princeFX = null;

    render();
    requestAnimationFrame(loop);
  }

  function nextLevel(){
    elCleared.style.display='none';
    level++;
    updateLevelHUD();
    continueNextLevel();
  }

  function clear(){ ctx.fillStyle='#020409'; ctx.fillRect(0,0,W,H); }
  function drawPlayer(){
    ctx.fillStyle = '#6dff97';
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillRect(player.x+player.w/2-3, player.y-6, 6, 6);
  }
  function drawSwarm(){
    for (const e of swarm.list){
      ctx.fillStyle = e.color;
      ctx.fillRect(e.x, e.y, e.w, e.h);
      ctx.fillStyle = 'rgba(0,0,0,.25)';
      ctx.fillRect(e.x+3, e.y+3, e.w-6, e.h-6);
    }
  }
  function drawBoss(animTime){
    if (!boss) return;
    if (boss.type === 'prince'){
      renderPrinceBoss32(ctx, boss, animTime, boss.hurt || 0, 3);
    } else {
      ctx.fillStyle = 'rgba(255,223,75,1)';
      ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
      ctx.fillStyle = '#000';
      ctx.fillRect(boss.x + boss.w/2 - 30, boss.y - 12, 60, 12);
      for (let i=0;i<5;i++){
        ctx.beginPath();
        ctx.moveTo(boss.x + boss.w/2 - 26 + i*13, boss.y - 12);
        ctx.lineTo(boss.x + boss.w/2 - 20 + i*13, boss.y - 24);
        ctx.lineTo(boss.x + boss.w/2 - 14 + i*13, boss.y - 12);
        ctx.closePath(); ctx.fill();
      }
    }
  }
  function drawBullets(){ ctx.fillStyle='#ff6b6b'; for (const b of bullets) ctx.fillRect(b.x,b.y,b.w,b.h); }
  function drawEnemyBullets(){
    ctx.fillStyle='#9ad0ff';
    for (const eb of enemyBullets){
      if (eb.kind === 'royalSeal'){
        drawRoyalSeal(ctx, eb, eb.scale || 2);
      } else {
        ctx.fillRect(eb.x,eb.y,eb.w,eb.h);
      }
    }
  }
  function render(){
    clear();
    const animTime = performance.now();
    drawSwarm();
    drawBoss(animTime);
    drawEnemyBullets();
    drawBullets();
    drawPlayer();
    if (princeFX && princeFX.alive) drawDeathBurst(ctx, princeFX);
    ctx.fillStyle='rgba(109,255,151,.1)';
    ctx.fillRect(0, player.y+player.h+2, W, 1);
  }
})();
</script>
</body>
</html>
